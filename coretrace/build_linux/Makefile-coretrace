VPATH = ..
CC = /usr/bin/g++
CFLAGS = -fPIC -Wall -g -O3 -I../
CXXFLAGS = -std=c++11 $(CFLAGS)


CUDA_PATH       ?= /usr/local/cuda
CUDA_INC_PATH   ?= $(CUDA_PATH)/include
CUDA_BIN_PATH   ?= $(CUDA_PATH)/bin
CUDA_LIB_PATH   ?= $(CUDA_PATH)/lib

# CUDA code generation flags
GENCODE_FLAGS   := -gencode arch=compute_30,code=sm_30 \
        -gencode arch=compute_35,code=sm_35 \
        -gencode arch=compute_50,code=sm_50 \
        -gencode arch=compute_52,code=sm_52 \
        -gencode arch=compute_60,code=sm_60 \
        -gencode arch=compute_61,code=sm_61 \
        -gencode arch=compute_61,code=compute_61

# Common binaries
NVCC            ?= $(CUDA_BIN_PATH)/nvcc

# OS-architecture specific flags
ifeq ($(OS_SIZE),32)
	NVCCFLAGS := -m32
else
	NVCCFLAGS := -m64
endif


OBJECTS = \
    treemesh.o \
    apertureplane.o \
    check_intersection.o \
    determineelementintersectionnew.o \
    dumpsys.o \
    errors.o \
    generateray.o \
    input.o \
    interaction.o \
    intersect.o \
    mathproc.o \
    gpu_proc.o \
    newzstartforcubicsplinesurf.o \
    quadricsurfaceclosedform.o \
    root432.o \
    spencerandmurtysurfaceclosedform.o \
    stapi.o \
    suntoprimarystage.o \
    surface.o \
    surfacenormalerrors.o \
    surfacezatxypair.o \
    torusclosedform.o \
    raytrace.o \
    types.o \
    vshot.o


TARGET=coretrace.a

$(TARGET):$(OBJECTS)
	ar rs $(TARGET) $(OBJECTS)

generateray.o: generateray.cu
	$(NVCC) $(NVCCFLAGS) -O3 $(EXTRA_NVCCFLAGS) $(GENCODE_FLAGS) -I$(CUDA_INC_PATH) -o $@ -c $<

# -dc means the library is useable in multiple kernels. It will generally just get compiled
# inline
gpu_proc.o: gpu_proc.cu
	$(NVCC) $(NVCCFLAGS) -O3 $(EXTRA_NVCCFLAGS) $(GENCODE_FLAGS) -I$(CUDA_INC_PATH) -o $@ -c $<

check_intersection.o: check_intersection.cu
	$(NVCC) $(NVCCFLAGS) -O3 $(EXTRA_NVCCFLAGS) $(GENCODE_FLAGS) -I$(CUDA_INC_PATH) -o $@ -c $<


clean:
	rm -rf $(TARGET) $(OBJECTS)
